\chapter{Background}\label{chap:background}

This background section will explain some of the concepts, approaches, technologies and software architectures required to understand this thesis.
The findings from the pre-project in \cite{rekstadModelingEnvironmentCloud2020} will also be presented in more detail than the introduction, as the findings are central to this thesis.
Lastly, a section on open source software project management follows, as they shape many of the choices made in the implementation of a solution.

\section{Conceptual Modeling and Model-Driven Development}

\paragraph{Rationale}
\Acrfull{MDD} is the approach to software development which this thesis aims to support.
Therefore, and understanding of \acrshort{MDD} is beneficial, in order to see how an editor should work.

\paragraph{Modeling and abstraction}
The core of \acrshort{MDD} is the model.
The model is a human created construct, formed through humans working together to discuss and refine a problem domain until they reach a consensus of what abstractions help them solve the relevant problems~\cite[p.~154]{brambillaModeldrivenSoftwareEngineering2012}.
Humans perceive the world (and problem domain) as many different phenomena, and conceptual modeling is the act of trying to describe these at some level of abstraction~\cite[p.~1,408]{krogstieModelbasedDevelopmentEvolution2012}.
The model is assumed to resemble the phenomena and work the same way, and yet be simpler than the real world~\cite[p.~414]{krogstieModelbasedDevelopmentEvolution2012}.
Abstraction means to find something common in different observations of a phenomena, and \textit{generalize} their features, \textit{classify} coherent clusters of objects and \textit{aggregate} concepts into more complex ones~\cite[p.~1]{brambillaModeldrivenSoftwareEngineering2012}.
The model will never describe every aspect of the world perfectly, but can \textit{reduce} the world down to relevant aspects, and easily \textit{map} between model elements and real world phenomena~\cite[p.~1-2]{brambillaModeldrivenSoftwareEngineering2012}.


\paragraph{Modeling languages}
In order to describe the model, a \textit{language} is used.
To realize the benefits of \acrshort{MDD}, a \textit{formal language} is used.
The language can be textual or graphical, or both, and imposes a formally defined syntax on the modeler~\cite[p.~13]{brambillaModeldrivenSoftwareEngineering2012}.

\paragraph{Modeling tools}
The advantage of using a formal language is that it can be parsed and understood by software tools, as well as humans.
The tools can validate the model according to the syntax, and to specific rules for the domain.
Tools can also generate code, or execute the model itself.
The model can be transformed into other models, or text or graphics~\cite[p.~8]{brambillaModeldrivenSoftwareEngineering2012}.

\paragraph{\acrlong{MDD}}
The central idea of \acrlong{MDD} is that the model is the source of truth that \textit{drives} the rest of the engineering and development~\cite[p.~9]{brambillaModeldrivenSoftwareEngineering2012}.
There is not a separate model for analysis and for design, but a single one for both~\cite[p.~49]{evansDomaindrivenDesignTackling2004}.
The software code becomes an expression of the model itself, and changes to the code often happen as the result of changes to the model~\cite[p.~49]{evansDomaindrivenDesignTackling2004}.
Because the model and the software are so directly related, the \acrshort{MDD} approach is heavily reliant on tools to automate the tasks of validation and code generation.
The formal language may also sacrifice some of its human readability in order to be understood by tools~\cite[p.~232]{krogstieModelbasedDevelopmentEvolution2012}.
To solve this, one can use other tools that interpret, transform or present models in other ways~\cite[p.~233]{krogstieModelbasedDevelopmentEvolution2012}.
This increases the reliance on tools for \acrshort{MDD} even more.


\section{Model-Driven Development at NTNU in the Course TDT4250}

* TDT4250. Modeling, use of instances to validate model as you develop, validation of models.

\section{Eclipse Modeling Framework Editors for Ecore}

* Eclipse EMF offers different Ecore editors. Tree-editor is important for developers, and diagrams are important in runtime and end-users.

\section{Introduction to Tree Structures}

* Brief introduction to Tree Structures.

\section{Master-Detail Tree Editor}

* Master-detail Tree Editors. 

\section{The Eclipse Reflective Ecore Editor}

* Reflective Ecore Editor, its architecture, Commands in .Edit, works on any model.

\section{An Overview of EMF: Ecore Metamodel, XMI Serialization and GenModel for Code Generation}

* Ecore metamodel, EMF, XMI, genmodel. Adaptation of editors to special cases like Ecore model and Genmodel.

\section{Visual Studio Code's Custom Editor API}

* VSCode Custom Editor API enables any type of graphical editor to be made, not just text.

\section{Language Server Protocol Architecture}

* LSP from VSCode solves language-to-editor m*n combinations. There is already a need to move EMF from Eclipse to VSCode, it might need to move to IntelliJ etc. in the future.

\section{\acrlong{EMF} in the \Gls{cloud}}

* Recent development, EMF.Cloud Model Server, EMF.Cloud EMFJson, GLSP, GLSP Ecore Editor, GLSP Coffee Editor.

\section{Pre-project Findings about Architecture and Protocol for a Solution}

* The pre-project suggested an architecture for a VSCode Extension based on LSP. It confirmed the feasibility of the client-server model with a custom editor, the major blockers for this architecture.
  * It also suggested a data structure for general purpose tree editing.
  * It suggested a base protocol on which to build the TLSP on, but did not implement it.

\section{Pre-project Findings about Software Requirements}

* Non-functional requirements from empirical evidence, to increase the chance of project adoption of the Eclipse ecosystem.
    * Flexibility - customize rendering and logic for different models.
    * Configurability - alter or toggle behavior per-project based on config files.
    * Conforming to existing architectures that are empirically validated, and familiar to the Eclipse ecosystem developers.

* Functional requirements were extracted in pre-project from Eclipse IDE's EMF tree editors.
  * View models of different levels, from Ecore metamodel to model instances.
  * View model as a tree based on containment properties.
  * Create empty model files with the minimum file contents.
  * Edit model hierarchies by creating, deleting or moving tree nodes.
  * Edit tree node properties by using a form-based editor.
  * Saving model changes to xmi files.
  * Validation of models.
  * Generation of code from models.


\section{Open Source Software Project Management and Project Viability}

* What can make this Open Source software project viable and worth pursuing further? Anecdotal and empirical evidence, not research.
  * This project needs to live on after the delivery of the Thesis.
  * Correct open source licenses, and "licence hygience" wrt. copy-pasting. Eclipse Foundation do thorough licence reviews.
  * Use of programming languages accepted by the developer community.
  * Use of automated build systems accepted by the developer community.
  * Testable code to reduce legacy and maintenance burden.
  * Human readable, clean code. Correct use of Design Patterns. Clean separation of concerns.
  * Use of commonly used and recognized dependencies/libraries/frameworks/tools.
  * CI/CD.
  * Good developer documentation. Architecture diagrams. Informative Readme-files with pictures of the running software. Instructions for developer environment setup.
  * Google Design Documents (?). Not too common in this ecosystem, but valuable inside Google. Complements the readme.
  * Publicly available bug/issue tracker and roadmap.
  * Release management. Semantic versioning. Changelogs. More useful for end-users or those using this as a library/dependency.
  * Specific to Eclipse Foundation, is the "Eclipse Foundation Project Handbook" (https://www.eclipse.org/projects/handbook/) and its checklist.
  * Measures to reduce new-developer onboarding and friction.
