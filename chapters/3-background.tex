\chapter{Background}\label{chap:background}

This background section will explain some of the concepts, approaches, technologies and software architectures required to understand this thesis.
The findings from the pre-project in \cite{rekstadModelingEnvironmentCloud2020} will also be presented in more detail than the introduction, as the findings are central to this thesis.
Lastly, a section on open source software project management follows, as they shape many of the choices made in the implementation of a solution.

\section{Conceptual Modeling and Model-Driven Development}\label{sec:conceptual-modeling}

\input{chapters/3-background/1-mdd.tex}


\section{Model-Driven Development at NTNU in the Course TDT4250}\label{sec:tdt4250}
% * TDT4250. Modeling, use of instances to validate model as you develop, validation of models.

\input{chapters/3-background/2-tdt4250.tex}


\section{Eclipse Modeling Framework Editors for Ecore}\label{sec:emf-editors}

\input{chapters/3-background/3-emf-editors.tex}


\section{Introduction to Tree Structures}\label{sec:tree-structures}

\input{chapters/3-background/4-trees.tex}


\section{Master-Detail Tree Editor}\label{sec:master-detail}

\input{chapters/3-background/5-master-detail.tex}


\section{The Eclipse Reflective Ecore Editor}

* Reflective Ecore Editor, its architecture, Commands in .Edit, works on any model.
% TODO: remove? DUplicate of prev. section?

\section{An Overview of EMF:\ Ecore Metamodel, XMI Serialization and GenModel for Code Generation}\label{sec:emf-metamodel}
%TODO

\paragraph{Rationale}
The \acrfull{EMF} is the \acrlong{MDD} framework used in \gls{TDT4250}.
The tree editor will modify \gls{Ecore} models, so it helps to understand the concepts and names used in the \gls{Ecore} metamodel.
It is also useful to know the different tools and components in \acrshort{EMF}, because the tree editor intends to reuse as much of them as possible internally, to save development effort.

\paragraph{\acrlong{EMF}}
The \acrfull{EMF} is a part of the Eclipse Modeling project from the Eclipse Foundation.
It is a framework and code generation facility that lets developers define models.
The models can be java code, \gls{XMI} or \gls{UML}, and the other two can be generated~\cite[p.~14]{edmerksEMFEclipseModeling2009}.
This framework may be chosen as the tools for doing \acrlong{MDD} (see \cref{sec:conceptual-modeling}).
In EMF, the models are expressed with the \gls{Ecore} modeling language.
This modeling language is similar to \gls{UML} Class Diagrams, in terms of the concepts and what it can express~\cite[p.~16]{edmerksEMFEclipseModeling2009}.
The real world data that could fit inside a specific model is called a \textit{model instance}.

The framework was made to take use of the editing capabilities and utility of the \gls{Eclipse}~\cite{edmerksEMFEclipseModeling2009}.
This means that there is much tooling and integration for \acrshort{EMF} with \gls{Eclipse}.
For example, EMF can generate a plugin to edit model instances in \gls{Eclipse}.

%TODO
% eclipse editor plugins, language, codegen, ocl, serialization format

\paragraph{\Gls{Ecore} metamodel}
The modeling language in \acrshort{EMF} is \gls{Ecore}.
A \textit{metamodel} is the model of a model.
This means that Ecore is the metamodel for all models expressed using \acrshort{Ecore}.
Ecore is itself modeled in Ecore, so it is its own metamodel.


\paragraph{Model concepts}
The main concepts used in \gls{Ecore} to model, are \texttt{EClass}, \texttt{EAttribute}, \texttt{EReference} and \texttt{EDataType}%
\footnote{The name Ecore comes from EMF Core, and the `E' prefix for \texttt{EClass} etc.\ come from Ecore.}.
These are distinct objects with names, properties and inheritance, like in object oriented programming.
As for the metamodel, \texttt{EClass}, \texttt{EAttribute} and \texttt{EReference} are all extending \texttt{ENamedElement}, which defines their \texttt{name} property~\cite{edmerksEMFEclipseModeling2009}.

When modeling, \texttt{EClass} is used to create java classes.
The \texttt{EAttribute} and \texttt{EReference} are used to model class properties, like member variables.
An \texttt{EAttribute} defines a property, such as e.g. \textit{age} or \textit{address}, while \texttt{EReference} defines a reference/association to another \texttt{EClass}, e.g. \textit{parent} or \textit{order}.
The \texttt{EAttribute} has a attribute type, the \texttt{EDataType}, which can be e.g. \texttt{EInt} or \texttt{EString}~\cite{edmerksEMFEclipseModeling2009}.

Java class methods are modeled with another concept, the \texttt{EOperation}.
Lastly, everything in the model lives inside an \texttt{EPackage}, which represents a java package (or other kind of code module).
There are more concepts in \gls{Ecore}, but many are only used internally as part of the metamodel, to represent \gls{Ecore} itself.


\paragraph{\Acrshort{XMI} serialization}
When an \gls{Ecore} model is written as a text file, it needs \textit{serialization}.
The official format for serializing Ecore is \acrfull{XMI}.
This format is based on \acrfull{XML}.
Model instances can also be serialized as \acrshort{XMI}.
It is also possible to serialize \gls{Ecore} to other formats, like \gls{JSON}, using third party tools.
% serialization, standardized EMOF, default for ecore, XML,

\paragraph{\acrshort{EMF} java \acrshort{API}}
The java code generated by \acrshort{EMF} will by default extend a set of java classes defined by \acrshort{EMF}.
Instead of a generated \texttt{EClass} extending \texttt{java.lang.Object}, it extends \texttt{EObject}.
And instead of using an \texttt{ArrayList}, a collection in \gls{Ecore} will use a \texttt{EList}.
When creating a new instance, the class constructor is not used, but a Factory instance on the generated \texttt{EPackage} for the model.


All of these framework java-classes are the \acrshort{EMF} java \gls{API}.
They provide much of the power, flexibility, reflection and meta-modeling capabilities of \acrshort{EMF} in java.
For example, a program can work with a \acrshort{EMF} model without knowing the code beforehand, by using the reflection \acrshort{API} to retrieve names and properties of a model object.


The \acrshort{API} also provides utilities for working with the model.
There are \acrshortpl{API} for listing the children of an \texttt{EObject}, getting a human representation of it, and for modifying and observing state changes.
Another important \acrshort{API} is the \texttt{ResourceSet} and \texttt{Resource}, used to read and save models to serialized \acrshort{XMI} files.

\paragraph{GenModel code generation}

%TODO
% Template based, configuration options, model + .edit + .editor output

\paragraph{Custom code}
%TODO
% editing genmodel code. @generated NOT annotation


* Ecore metamodel, EMF, XMI, genmodel. Adaptation of editors to special cases like Ecore model and Genmodel.

\section{Visual Studio Code's Custom Editor API}\label{sec:vscode-custom-editor}
%TODO
* VSCode Custom Editor API enables any type of graphical editor to be made, not just text.

\section{Language Server Protocol Architecture}\label{sec:lsp}
%TODO
* LSP from VSCode solves language-to-editor m*n combinations. There is already a need to move EMF from Eclipse to VSCode, it might need to move to IntelliJ etc. in the future.
* Monaco general frontend. Also Eclipse uses LSP with JDT? IntelliJ??

\section{\Gls{cloud} and \gls{Gitpod}}
%TODO

\section{\acrlong{EMF} in the \Gls{cloud}}
%TODO
* Recent development, EMF.Cloud Model Server, EMF.Cloud EMFJson, GLSP, GLSP Ecore Editor, GLSP Coffee Editor.

\section{Pre-project Results}

\input{chapters/3-background/10-pre-project-findings.tex}


\section{Open Source Software Project Management and Project Viability}

* What can make this Open Source software project viable and worth pursuing further? Anecdotal and empirical evidence, not research.
  * This project needs to live on after the delivery of the Thesis.
  * Correct open source licenses, and "licence hygience" wrt. copy-pasting. Eclipse Foundation do thorough licence reviews.
  * Use of programming languages accepted by the developer community.
  * Use of automated build systems accepted by the developer community.
  * Testable code to reduce legacy and maintenance burden.
  * Human readable, clean code. Correct use of Design Patterns. Clean separation of concerns.
  * Use of commonly used and recognized dependencies/libraries/frameworks/tools.
  * CI/CD.
  * Good developer documentation. Architecture diagrams. Informative Readme-files with pictures of the running software. Instructions for developer environment setup.
  * Google Design Documents (?). Not too common in this ecosystem, but valuable inside Google. Complements the readme.
  * Publicly available bug/issue tracker and roadmap.
  * Release management. Semantic versioning. Changelogs. More useful for end-users or those using this as a library/dependency.
  * Specific to Eclipse Foundation, is the "Eclipse Foundation Project Handbook" (https://www.eclipse.org/projects/handbook/) and its checklist.
  * Measures to reduce new-developer onboarding and friction.
