\chapter{Background}\label{chap:background}

This background section will explain some of the concepts, approaches, technologies and software architectures required to understand this thesis.
The findings from the pre-project in \cite{rekstadModelingEnvironmentCloud2020} will also be presented in more detail than the introduction, as the findings are central to this thesis.
Lastly, a section on open source software project management follows, as they shape many of the choices made in the implementation of a solution.

\section{Conceptual Modeling and Model-Driven Development}\label{sec:conceptual-modeling}

\input{chapters/3-background/1-mdd.tex}


\section{Model-Driven Development at NTNU in the Course TDT4250}\label{sec:tdt4250}
% * TDT4250. Modeling, use of instances to validate model as you develop, validation of models.

\input{chapters/3-background/2-tdt4250.tex}


\section{Eclipse Modeling Framework Editors for Ecore}

\paragraph{Rationale}
These editors are the ones being re-implemented in \gls{cloud}-based \acrshortpl{IDE}.
Understanding their functionality and workings is important, as these editors shape the work of this thesis.
The functionalities provided are assumed highly usable and good, because they are the result of many years of work and experience.
This allows this thesis to skip the work of doing usability testing with regards to feature design, as long as the features are similar enough to the copied ones.

\paragraph{Multiple editors}
When editing \gls{Ecore} models in \gls{Eclipse}, there are different editors to pick from.
Usually, \gls{Ecore} models and model instances are saved as \acrfull{XMI}, which is a standardized serialization format based on XML.
However, \gls{Ecore} models are rarely (if ever) edited as XML.
Instead, the files are loaded and presented in a tree structure editor or diagram editor.
These editors are specialized for \gls{Ecore}, and can understand the model.
The diagram based editors use a notation that is based on \gls{UML} Class Diagrams, with boxes, labels and arrows.
Which editor to use can often be a personal preference.
They are all functionally equivalent, with regards to modeling.
The next subsections will describe the most common editors in more detail.

\subsection{Sample Reflective Ecore Model Editor}\label{sec:sample-reflective-editor}

The ``\textit{Sample Reflective Ecore Model Editor}'' is one of the main \gls{Ecore} editors in \gls{Eclipse}.
The model instances can be edited in a \textit{reflective} editor (without the user first generating java code and installing an \gls{Eclipse} plugin).
Here, reflective means that the editor uses a metamodel (see \cref{sec:emf-metamodel}) for the model instance, and tries to infer the tree structure from containment relationships.


This editor is \gls{open source}%
\footnote{Sample Reflective editor source: \href{https://git.eclipse.org/c/emf/org.eclipse.emf.git/tree/plugins/org.eclipse.emf.ecore.editor}{\nolinkurl{https://git.eclipse.org/c/emf/org.eclipse.emf.git/tree/plugins/org.eclipse.emf.ecore.editor}}.}%
, and the editor is itself originally generated by a genmodel~\cite[p.~10]{rekstadModelingEnvironmentCloud2020}.
This editor internally uses a java class called \texttt{ReflectiveItemProvider}%
\footnote{\texttt{ReflectiveItemProvider} source code: \href{https://git.eclipse.org/c/emf/org.eclipse.emf.git/tree/plugins/org.eclipse.emf.edit/src/org/eclipse/emf/edit/provider/ReflectiveItemProvider.java}{\nolinkurl{https://git.eclipse.org/c/emf/org.eclipse.emf.git/tree/plugins/org.eclipse.emf.edit/src/org/eclipse/emf/edit/provider/ReflectiveItemProvider.java}}}
from the \texttt{org.eclipse.emf.edit} \acrshort{EMF} package, to extract text labels and infer icons for the tree view~\cite[p.~10]{rekstadModelingEnvironmentCloud2020}.

For \gls{Ecore} models (with \texttt{.ecore} file exntension, not model instances), it uses an \texttt{EcoreItemProviderAdapterFactory}%
\footnote{\texttt{EcoreItemProviderAdapterFactory} source code: \href{https://git.eclipse.org/c/emf/org.eclipse.emf.git/tree/plugins/org.eclipse.emf.ecore.edit/src/org/eclipse/emf/ecore/provider/EcoreItemProviderAdapterFactory.java}{\nolinkurl{https://git.eclipse.org/c/emf/org.eclipse.emf.git/tree/plugins/org.eclipse.emf.ecore.edit/src/org/eclipse/emf/ecore/provider/EcoreItemProviderAdapterFactory.java}}}
to get labels and icons~\cite{edmerksEcoreEditorJava2021}.

These ``item providers'' are especially interesting, because they could be reused in a new editor.

% TODO: insert picture of sample reflective. Pre-project figure 2.3.

\subsection{EMF Forms Ecore Editor}\label{sec:emfforms-editor}
%TODO

\subsection{Ecore Tools diagrammatical editor}\label{sec:ecore-tools-editor}
%TODO

\subsection{EMF.Cloud ecore-glsp diagrammatical editor}\label{sec:ecore-glsp-editor}
%TODO



%* Eclipse EMF offers different Ecore editors. Tree-editor is important for developers, and diagrams are important in runtime and end-users.

\section{Introduction to Tree Structures}

* Brief introduction to Tree Structures.

\section{Master-Detail Tree Editor}

* Master-detail Tree Editors. 

\section{The Eclipse Reflective Ecore Editor}

* Reflective Ecore Editor, its architecture, Commands in .Edit, works on any model.
% TODO: remove? DUplicate of prev. section?

\section{An Overview of EMF: Ecore Metamodel, XMI Serialization and GenModel for Code Generation}\label{sec:emf-metamodel}

* Ecore metamodel, EMF, XMI, genmodel. Adaptation of editors to special cases like Ecore model and Genmodel.

\section{Visual Studio Code's Custom Editor API}

* VSCode Custom Editor API enables any type of graphical editor to be made, not just text.

\section{Language Server Protocol Architecture}

* LSP from VSCode solves language-to-editor m*n combinations. There is already a need to move EMF from Eclipse to VSCode, it might need to move to IntelliJ etc. in the future.

\section{\acrlong{EMF} in the \Gls{cloud}}

* Recent development, EMF.Cloud Model Server, EMF.Cloud EMFJson, GLSP, GLSP Ecore Editor, GLSP Coffee Editor.

\section{Pre-project Findings about Architecture and Protocol for a Solution}

* The pre-project suggested an architecture for a VSCode Extension based on LSP. It confirmed the feasibility of the client-server model with a custom editor, the major blockers for this architecture.
  * It also suggested a data structure for general purpose tree editing.
  * It suggested a base protocol on which to build the TLSP on, but did not implement it.

\section{Pre-project Findings about Software Requirements}

* Non-functional requirements from empirical evidence, to increase the chance of project adoption of the Eclipse ecosystem.
    * Flexibility - customize rendering and logic for different models.
    * Configurability - alter or toggle behavior per-project based on config files.
    * Conforming to existing architectures that are empirically validated, and familiar to the Eclipse ecosystem developers.

* Functional requirements were extracted in pre-project from Eclipse IDE's EMF tree editors.
  * View models of different levels, from Ecore metamodel to model instances.
  * View model as a tree based on containment properties.
  * Create empty model files with the minimum file contents.
  * Edit model hierarchies by creating, deleting or moving tree nodes.
  * Edit tree node properties by using a form-based editor.
  * Saving model changes to xmi files.
  * Validation of models.
  * Generation of code from models.


\section{Open Source Software Project Management and Project Viability}

* What can make this Open Source software project viable and worth pursuing further? Anecdotal and empirical evidence, not research.
  * This project needs to live on after the delivery of the Thesis.
  * Correct open source licenses, and "licence hygience" wrt. copy-pasting. Eclipse Foundation do thorough licence reviews.
  * Use of programming languages accepted by the developer community.
  * Use of automated build systems accepted by the developer community.
  * Testable code to reduce legacy and maintenance burden.
  * Human readable, clean code. Correct use of Design Patterns. Clean separation of concerns.
  * Use of commonly used and recognized dependencies/libraries/frameworks/tools.
  * CI/CD.
  * Good developer documentation. Architecture diagrams. Informative Readme-files with pictures of the running software. Instructions for developer environment setup.
  * Google Design Documents (?). Not too common in this ecosystem, but valuable inside Google. Complements the readme.
  * Publicly available bug/issue tracker and roadmap.
  * Release management. Semantic versioning. Changelogs. More useful for end-users or those using this as a library/dependency.
  * Specific to Eclipse Foundation, is the "Eclipse Foundation Project Handbook" (https://www.eclipse.org/projects/handbook/) and its checklist.
  * Measures to reduce new-developer onboarding and friction.
