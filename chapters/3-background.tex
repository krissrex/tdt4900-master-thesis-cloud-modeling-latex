\chapter{Background}\label{chap:background}

This background section will explain some of the concepts, approaches, technologies and software architectures required to understand this thesis.
The findings from the pre-project in \cite{rekstadModelingEnvironmentCloud2020} will also be presented in more detail than the introduction, as the findings are central to this thesis.
Lastly, a section on open source software project management follows, as they shape many of the choices made in the implementation of a solution.

\section{Conceptual Modeling and Model-Driven Development}\label{sec:conceptual-modeling}

\input{chapters/3-background/1-mdd.tex}


\section{Model-Driven Development at NTNU in the Course TDT4250}\label{sec:tdt4250}
% * TDT4250. Modeling, use of instances to validate model as you develop, validation of models.

\input{chapters/3-background/2-tdt4250.tex}


\section{Eclipse Modeling Framework Editors for Ecore}\label{sec:emf-editors}

\input{chapters/3-background/3-emf-editors.tex}


\section{Introduction to Tree Structures}\label{sec:tree-structures}

\input{chapters/3-background/4-trees.tex}


\section{Master-Detail Tree Editor}\label{sec:master-detail}

\input{chapters/3-background/5-master-detail.tex}


\section{The Eclipse Reflective Ecore Editor}

* Reflective Ecore Editor, its architecture, Commands in .Edit, works on any model.
* Adaptation of editors to special cases like Ecore model and Genmodel.
% TODO: remove? DUplicate of prev. section?

\section{An Overview of EMF:\ Ecore Metamodel, XMI Serialization and GenModel for Code Generation}\label{sec:emf-metamodel}

\input{chapters/3-background/6-emf.tex}


\section{Visual Studio Code's Custom Editor API}\label{sec:vscode-custom-editor}
%TODO
* VSCode Custom Editor API enables any type of graphical editor to be made, not just text.

\section{JSON-RPC}

\section{Language Server Protocol Architecture}\label{sec:lsp}
%TODO
* LSP from VSCode solves language-to-editor m*n combinations. There is already a need to move EMF from Eclipse to VSCode, it might need to move to IntelliJ etc. in the future.
* Monaco general frontend. Also Eclipse uses LSP with JDT? IntelliJ??


\section{\Gls{cloud} and \gls{Gitpod}}

\paragraph{Cloud}
The \gls{cloud} is the term used for rented computing power and data storage in data centers owned by third parties.
This is in contrast to in-house or on-premise servers.
An advantage of running software in the \gls{cloud} is that maintenance of hardware is out sourced.
If a hard drive or processor breaks down, it is the cloud vendor's responsibility to fix, and to provide failover mechanisms so a customer is not impacted.


Another advantage is the ability to scale up or down instantly on demand.
If a on-premise server is overloaded, the organization has to purchase more servers and configure them.
Just the shipping of hardware alone takes more time than requesting more compute power from a \gls{cloud} provider.
The cloud providers usually have so large data centers that they never ``run out'', as long as a customer is able to pay for it.
Some of the best known cloud providers today are Amazon with Amazon Web Services, Google with Google Cloud, and Microsoft with Azure.

\paragraph{Gitpod}
Gitpod is a \gls{cloud} based \acrfull{IDE}.
It is provided as a service, or it can be self hosted.
The idea behind \gls{Gitpod} is that a developer does not need to install the tools on their own machine.
Instead, a machine is provisioned at a cloud provider, and any tools are installed there.
The developer interfaces with this machine through a web based \acrshort{IDE}.
For Gitpod, the default \acrshort{IDE} is \gls{Theia}.
The source code is downloaded from an online source code host, such as \gls{GitHub}, and into a workspace on the provisioned machine. %TODO: cite?

\section{\acrlong{EMF} in the \Gls{cloud}}
%TODO
* Recent development, EMF.Cloud Model Server, EMF.Cloud EMFJson, GLSP, GLSP Ecore Editor, GLSP Coffee Editor.

\section{Pre-project Results}

\input{chapters/3-background/10-pre-project-findings.tex}


\section{Open Source Software Project Management and Project Viability}

* What can make this Open Source software project viable and worth pursuing further? Anecdotal and empirical evidence, not research.
  * This project needs to live on after the delivery of the Thesis.
  * Correct open source licenses, and "licence hygience" wrt. copy-pasting. Eclipse Foundation do thorough licence reviews.
  * Use of programming languages accepted by the developer community.
  * Use of automated build systems accepted by the developer community.
  * Testable code to reduce legacy and maintenance burden.
  * Human readable, clean code. Correct use of Design Patterns. Clean separation of concerns.
  * Use of commonly used and recognized dependencies/libraries/frameworks/tools.
  * CI/CD.
  * Good developer documentation. Architecture diagrams. Informative Readme-files with pictures of the running software. Instructions for developer environment setup.
  * Google Design Documents (?). Not too common in this ecosystem, but valuable inside Google. Complements the readme.
  * Publicly available bug/issue tracker and roadmap.
  * Release management. Semantic versioning. Changelogs. More useful for end-users or those using this as a library/dependency.
  * Specific to Eclipse Foundation, is the "Eclipse Foundation Project Handbook" (https://www.eclipse.org/projects/handbook/) and its checklist.
  * Measures to reduce new-developer onboarding and friction.
