\chapter{Background}\label{chap:background}

This background section will explain some of the concepts, approaches, technologies and software architectures required to understand this thesis.
The findings from the pre-project in \cite{rekstadModelingEnvironmentCloud2020} will also be presented in more detail than the introduction, as the findings are central to this thesis.
Lastly, a section on open source software project management follows, as they shape many of the choices made in the implementation of a solution.

\section{Conceptual Modeling and Model-Driven Development}\label{sec:conceptual-modeling}

\input{chapters/3-background/1-mdd.tex}


\section{Model-Driven Development at NTNU in the Course TDT4250}\label{sec:tdt4250}
% * TDT4250. Modeling, use of instances to validate model as you develop, validation of models.

\input{chapters/3-background/2-tdt4250.tex}


\section{Eclipse Modeling Framework Editors for Ecore}

* Eclipse EMF offers different Ecore editors. Tree-editor is important for developers, and diagrams are important in runtime and end-users.

\section{Introduction to Tree Structures}

* Brief introduction to Tree Structures.

\section{Master-Detail Tree Editor}

* Master-detail Tree Editors. 

\section{The Eclipse Reflective Ecore Editor}

* Reflective Ecore Editor, its architecture, Commands in .Edit, works on any model.

\section{An Overview of EMF: Ecore Metamodel, XMI Serialization and GenModel for Code Generation}

* Ecore metamodel, EMF, XMI, genmodel. Adaptation of editors to special cases like Ecore model and Genmodel.

\section{Visual Studio Code's Custom Editor API}

* VSCode Custom Editor API enables any type of graphical editor to be made, not just text.

\section{Language Server Protocol Architecture}

* LSP from VSCode solves language-to-editor m*n combinations. There is already a need to move EMF from Eclipse to VSCode, it might need to move to IntelliJ etc. in the future.

\section{\acrlong{EMF} in the \Gls{cloud}}

* Recent development, EMF.Cloud Model Server, EMF.Cloud EMFJson, GLSP, GLSP Ecore Editor, GLSP Coffee Editor.

\section{Pre-project Findings about Architecture and Protocol for a Solution}

* The pre-project suggested an architecture for a VSCode Extension based on LSP. It confirmed the feasibility of the client-server model with a custom editor, the major blockers for this architecture.
  * It also suggested a data structure for general purpose tree editing.
  * It suggested a base protocol on which to build the TLSP on, but did not implement it.

\section{Pre-project Findings about Software Requirements}

* Non-functional requirements from empirical evidence, to increase the chance of project adoption of the Eclipse ecosystem.
    * Flexibility - customize rendering and logic for different models.
    * Configurability - alter or toggle behavior per-project based on config files.
    * Conforming to existing architectures that are empirically validated, and familiar to the Eclipse ecosystem developers.

* Functional requirements were extracted in pre-project from Eclipse IDE's EMF tree editors.
  * View models of different levels, from Ecore metamodel to model instances.
  * View model as a tree based on containment properties.
  * Create empty model files with the minimum file contents.
  * Edit model hierarchies by creating, deleting or moving tree nodes.
  * Edit tree node properties by using a form-based editor.
  * Saving model changes to xmi files.
  * Validation of models.
  * Generation of code from models.


\section{Open Source Software Project Management and Project Viability}

* What can make this Open Source software project viable and worth pursuing further? Anecdotal and empirical evidence, not research.
  * This project needs to live on after the delivery of the Thesis.
  * Correct open source licenses, and "licence hygience" wrt. copy-pasting. Eclipse Foundation do thorough licence reviews.
  * Use of programming languages accepted by the developer community.
  * Use of automated build systems accepted by the developer community.
  * Testable code to reduce legacy and maintenance burden.
  * Human readable, clean code. Correct use of Design Patterns. Clean separation of concerns.
  * Use of commonly used and recognized dependencies/libraries/frameworks/tools.
  * CI/CD.
  * Good developer documentation. Architecture diagrams. Informative Readme-files with pictures of the running software. Instructions for developer environment setup.
  * Google Design Documents (?). Not too common in this ecosystem, but valuable inside Google. Complements the readme.
  * Publicly available bug/issue tracker and roadmap.
  * Release management. Semantic versioning. Changelogs. More useful for end-users or those using this as a library/dependency.
  * Specific to Eclipse Foundation, is the "Eclipse Foundation Project Handbook" (https://www.eclipse.org/projects/handbook/) and its checklist.
  * Measures to reduce new-developer onboarding and friction.
