\chapter{Method}\label{chap:method}

The method used will try to achieve the project objectives with correct results, and avoid or lower risks for project failure.


The project is a failure if the results are invalid, or cannot be realized into a real solution, or are so low quality that the project does not receive further development.
The project is also a failure if it does not provide any value for its stakeholders.


The following sections describe the key elements to the method.
There is an overarching approach, called Design Science Research.
It has 6 phases, from problem identification, to development, to evaluation and communication.
There is no methodology given by Design Science Research for executing the development phase.
Therefore, a method for this phase must be crafted from experience and existing practice.
The development phase consists of requirements engineering methods, and software development methods.


\section{Design Science Research}
%* Design Science. Build and evaluate value. Contribute to knowledge base. Is this software we need?

\input{chapters/5-method/1-design-science.tex}


\section{Requirements Engineering}

In Design Science Research, there is little guidance for how to execute the actual \textit{design and development} phase.
However, the software engineering field has many approaches and ideas for how to do this.


The design of the artifact starts by gathering requirements.
These specify the concrete behaviors of the artifact; both the behaviors required for achieving the research objectives in \cref{sec:research-objectives}, and those required for a highly useable and valuable solution.


The identified requirements are both part of the design, and influence the design.
Most requirements are formed from existing knowledge of the background theory.
They are also discovered as the solution is developed.
The following subsections \ref{subsec:req-stakeholder}-\ref{subsec:req-agile} describe the key inputs for the software requirement engineering process.


\subsection{Stakeholder Discussion}\label{subsec:req-stakeholder}

Discussion with stakeholders reveal many requirements, use cases and needs.
The two key types of stakeholders here are \acrshort{EMF} experts and \gls{TDT4250} students.
The supervisor, Hallvard Tr√¶tteberg, fills the role as both a \acrshort{EMF} expert and lecturer of \gls{TDT4250}.
The author, Kristian Rekstad, fills the role as a \gls{TDT4250} student.


Dialogue questions include ``What features are required to model with \acrshort{EMF}?'' and ``What features would you like to see in a new solution?'', as well as ``Which features are missing from the existing solutions?''.


The same questions can be asked both before realizing a solution, and underway as the response to prototypes and current progress of an unfinished solution.


\subsection{Requirements Extraction}

\paragraph{Based on existing editors}
The existing tree editors in \gls{Eclipse} already implement every feature needed to do \acrlong{MDD} with the \acrlong{EMF}.
Therefore, they are excellent sources of requirements.
Especially the Sample Reflective Ecore Editor and EMF Forms Ecore Editor. %TODO: cref sections


\paragraph{No official requirements lists}
The pre-study failed to find any related research detailing requirements for a tree editor~\cite[p.~3]{rekstadModelingEnvironmentCloud2020}.
No design documents or requirements specifications were found for the \gls{Ecore} editors in \gls{Eclipse} either.


\paragraph{Use cases and requirement detection}
Therefore, the approach became to extract the requirements from the \gls{Ecore} tree editors.
The extraction is done by following use cases of modeling, as described in \cref{par:tdt4250-methodology}.
When a new functional requirement is discovered through use, it is recorded in a list.


\paragraph{Shortcomings}
This approach will find many of the required and ``obvious'' requirements.
However, hidden functionality and expert level functionality is not guaranteed to be found.
The rationale is that this functionality is not needed (yet) anyways, as the goal is to fulfil the common use cases that students have when learning \acrshort{MDD}.


There is also a risk that the user which is recording the requirements fail to detect functionality.
Some functionality can be so obvious or ``second nature'' that the user is oblivious to it.
Such functionality \textit{should} become apparent later, however, when the solution is developed and tested.
Any big omissions will prevent the use cases from succeeding.


\subsection{Source Code Analysis of Similar Projects}

\paragraph{Open source editors}
Because the tree editors for \gls{Ecore} in \gls{Eclipse} are \gls{open source}, it is possible to read and analyze the source code.
Finding the main classes responsible for editor functionality, and analyzing their method names, initialization procedures and method calls, may expose requirements.
This approach may also detect some of the more hidden functionalities, and the more ``internal'' functional requirements.


\paragraph{Architecture and software re-use}
Another advantage is that the internal architecture and patterns are exposed, which can be used to influence the artifact design.
This may increase familiarity with the design for the Eclipse ecosystem, aiding the \gls{open source} goals of this project.
It also highlights the opportunities for software re-use, when familiar code, classes, interfaces, design patterns or software libraries are used.


\paragraph{Shortcomings}
Source code analysis is dependant on analyzing the correct source code files.
If they are not found, this will fail.
This also requires the source code to have some level of quality and readability to be useful for someone not already invested in that editor code base.
The software architecture and design patterns used will matter too, in case functionality is hidden, dispersed or not clearly visible from the source code.


\subsection{Use Cases and Prototyping}

Creating realistic use cases based on \cref{par:tdt4250-methodology}, and executing them with early versions or prototypes will detect missing requirements.
This is because a user will be blocked from progressing if a critical functionality is missing.
%For example here: copy-paste, keyboard shortcuts etc)


\subsection{Agile Requirements}\label{subsec:req-agile}

\paragraph{Agile}
Core values during this thesis' requirements engineering process come from \textit{Agile}.
Agile is a counterpart to the Waterfall process\footnote{In waterfall, software is designed, developed and tested in very separate stages. All the requirements are collected, before any design or development begins. An early mistake will not be discovered until the very end of the process. Changes to requirements require a restart of the project phases.}


\paragraph{Change over Plan}
It embraces the fact that requirements change during the design and development, and thus favors \textbf{responding to change} over following a plan~\cite{kentbeckManifestoAgileSoftware2001}.
Requirements will change as they are discovered, refined and better understood later on.


\paragraph{Software over Documentation}
Another key value is that Agile prefers \textbf{working software} over comprehensive documentation~\cite{kentbeckManifestoAgileSoftware2001}.
This means that a small, working software artifact is more valuable than a large, complete and consistent list of software requirements and design, without any working software to show for it.


\paragraph{Impact of agile on requirements engineering}
The result is that the method here will start by collecting \textit{some} requirements, by using the previously described inputs.
When there are enough requirements to sufficiently solve the known use cases, design and development can begin.
There is no goal to create a complete list at the start.
The requirements are also changed, and new ones added, during the design and development.


\section{Development Methodologies}

The case for software development is the same as with requirements engineering: Design Science Research has little guidance.
And again, the software engineering field has the answers.


The goal for the development methodology is to \textbf{create the right solution}, which solves the identified problem and fulfils the software requirements.
The methodology also aims to \textbf{avoid or reduce risks} for project failure, by tackling it as early as possible.
Research often deviates from routine design here, by going for the risks first instead of delaying or hiding them, as this may lead to new knowledge~\cite[p.~114]{oatesResearchingInformationSystems2006}.


Another goal for the development process is to create ``good'', high quality software, so the project can be accepted by the \gls{open source} developer ecosystem for further development and maintenance.
Bad code or a bad design may result in a full rewrite by the next interested developer, or the developer may try to contribute but find it hard and give up.


Development methodology will not follow one strict practice, but rather piece together many different practices and values, which have lead to good results in the author's past.


\subsection{Agile}

Development will follow agile values and principles, as described in \citetitle{kentbeckManifestoAgileSoftware2001} and \citetitle{PrinciplesAgileManifesto}.
This means iterative development, rapid feedback from stakeholders, and working software.

\paragraph{Agile development}
As there are many unknown factors in development, such as third party components and services to comply and integrate with, and unknown and hard to use \glspl{API}, the plans and designs may change.
As with software requirements, the data structures, algorithms and design in the software solution will have to change as the developer learns the systems and problem space better.
\textbf{Responding to change} will be valued more than following a plan here.
Also, \textbf{working software} is more valuable than extensive documentation, meaning that code comments, tests, design specifications and diagrams will be given less effort than code, particularly if done up-front before the code.
The alternative is that this documentation is made, but the code for it quickly proves itself impossible to make, or there is not enough time to implement it, leaving only useless documentation as the result.
This also ties in to \textbf{simplicity and maximizing work-not-done}.


Regular reflection will be used weekly or bi-weekly, to assess if the process can be more effective.
Sometimes tools and technologies may seem like a good fit for the development, but instead wastes more time than the developer productivity provided.
Retrospective analysis of the development progress will try to detect this, and then expose if bad approaches are used.
If so, these will be removed or replaced if possible.


Stakeholder involvement is important as well.
The development will have a stakeholder as the developer (the author), which knows how the artifact will be used.
Additionally, the supervisor will se a demo during development, to provide feedback and help prioritize the next steps.


\subsection{Iterative Development}
* Iterative development. Work on one component at the time, up to a minimum level of functionality. Then come back later and add more.


\subsection{Lean and Minimum Viable Product}

* Lean development. Create a minimum viable product and see if it works.

\subsection{Domain Driven Design}

* Domain driven design. Increase software quality, developer understanding and software re-use with layered architecture, domain layer and ubiquitous domain language.

\subsection{Test Driven Development}

* Test driven development, where applicable. Verify behavior of critical logic, to reduce bugs and increase developer confidence and speed.

\subsection{Tracer Bullets}
* Tracer bullets. Reduce risk from integration by connecting all the major components, before developing any component fully.

\subsection{Prototyping}

* Pre-project with prototyping. Reduce risk by testing feasibility early. Creates more learning, validates requirements and discovers new requirements.


\section{Evaluation}

\input{chapters/5-method/4-evaluation.tex}
